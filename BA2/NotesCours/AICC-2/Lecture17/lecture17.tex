\documentclass[a4paper]{article}

% Expanded on 2022-04-26 at 15:16:32.

\usepackage{../../style}

\title{AICC 2}
\author{Joachim Favre}
\date{Mardi 26 avril 2022}

\begin{document}
\maketitle

\lecture{17}{2022-04-26}{Digital signatures}{
    \begin{itemize}[left=0pt]
        \item End of explanation of the RSA algorithm.
        \item Explanation on how to sign documents using trapdoor one-way functions.
    \end{itemize}
}

\parag{Decoding exponent}{
    We can note that such $d$ are not unique. Let's say we found $ed = k \ell + 1$. Let's add $ek \alpha$ (where $\alpha$ is an arbitrary number) on both sides, yielding:  
    \[ed + ek \alpha = k \ell + 1 + ek \alpha \iff e\left(d + k \alpha\right) = k\left(\ell + e \alpha\right) + 1\]
    
    Thus, picking $\widetilde{d} = d + k\alpha$ and $\widetilde{\ell} = \ell + e\alpha$, we get: 
    \[e\widetilde{d} = k\widetilde{\ell} + 1\]
    
    Thus, they are not unique. This is especially useful when we found a negative $d$, and actually wanted a positive one for RSA.

    \subparag{Remark}{
        This reasoning works for any pair of numbers generated by Bézout's construction.
    }
}

\parag{Encoding exponent}{
    We want $e$ to be as small as small possible, since it allows to need less computation power. 

    $e$ is usually chosen to be equal to $e = 65537 = 2^{16} + 1$. This is very nice, since it allows us to compute $t^e$ by doing:
    \[t^e = t^{2^{16}} \cdot t = \left(\left(\left(t\right)^2\right)^2 \ldots \right)^2 \cdot t\]

    This is like doing the fast-exponentiation algorithm, but needs (slightly) less multiplications afterhand.
}

\parag{Fast exponentiation}{
    RSA is based on the efficiency of our algorithms to compute $a^k \Mod m$. 

    Let $k$ be such that $0 \leq k \leq m-1$ (we do not need to go higher since we know $a^{m} \Mod m = m$). We know we can write it in its binary representation: 
    \[k = \sum_{i=0}^{L-1} b_i 2^{i}, \mathspace \text{where } b_i \in \left\{0, 1\right\}\]
    
    Thus, $a^k$ is given by: 
    \[a^k = a^{\sum_{i=0}^{L-1} b_i 2^i} = \prod_{i=0}^{L-1} a^{b_i 2^i} = \prod_{i=0}^{L - 1} \left(a^{2^i}\right)^{b_i} = \prod_{i=0}^{L - 1}  a_i^{b_i}\]
    where $a_i$ will be defined right after.

    Also, taking everything mod $m$, we get: 
    \[a^k \Mod m = \left(\prod_{i=0}^{L-1} a_i^{b_i}\right) \Mod m = \left(\prod_{i=0}^{L-1} \left(a_i \Mod m\right)^{b_i}\right) \Mod m\]
    
    We only need to compute all the $a_i$, and multiply all for which $b_i = 1$, taking a mod at each step. To compute $a_i = a^{2^{i}}$, we can compute them recursively very easily: 
    \[a_0 = a \Mod m, \mathspace a_i = \left(a_{i-1}\right)^2\]
    
    We see that it takes $L-1$ multiply-mod to find all $a_i$, and it takes at most $L-1$ multiply-mod to then compute $a^k \Mod m$. Thus, we need $2\left(L-1\right)$ multiply-mod to compute our number. We notice that with $L$ bits, we can take any number $k$ such that $0 \leq k \leq 2^L - 1$. However, we know that $k \leq m - 1$, so $2^L = m \iff L = \log_2\left(m\right)$.

    Putting everything together, we see that we need $2\left(\log_2\left(m\right) - 1\right)$ multiply-mod to compute $a^k \Mod m$. In other words, this algorithm~---~named fast exponentiation~---~is $\Theta\left(\log\left(m\right)\right)$.
}

\parag{RSA summary}{
    Let's build again RSA, from start, to see the whole reasoning and to help memorise.

    \subparag{Wrong RSA}{
        Let $k \in \mathbb{Z}$. The magic that makes RSA work is that there exists a magic number $\phi\left(p\right)$ such that: 
        \[\left[t^{k \phi\left(p\right)}\right]_p = \left[1\right]_p, \mathspace \forall t \in \mathbb{Z} / p\mathbb{Z}^*\]
        
        This universal exponent is really useful.

        Since we want $\left[t^{ed}\right]_p = \left[t\right]_p$, we can select $e$ and $d$ such that $ed = k\phi\left(p\right) + 1$. To do that, we can pick any $e$ (coprime with $k$), and then use extended Euclid algorithm to find $k$ and $d$.

        However, since we are publishing $e$ and $m = p$, the attacker can run the extended Euclid algorithm to find $d$, so this is not safe.
    }

    \subparag{Without mistake}{
        We want to do something smarter: we want that if we give $m$, then the other is not able to find $\phi\left(m\right)$. We know that Euler's totient function is very ``random'', meaning that we really have to know the prime factorisation of $m$ to compute $\phi\left(m\right)$. This implies that we can pick $m = pq$ where $p$ and $q$ are two primes, which means that $\phi\left(m\right) = \left(p-1\right)\left(q-1\right)$. This is very hard to find unless we know $p$ and $q$, and prime factorisation is really hard.

        We would already be done for $\left(\mathbb{Z} / m\mathbb{Z}^*\right)$, but we would prefer RSA to work for all elements $a \in \mathbb{Z} / pq\mathbb{Z}$. We will block the user from taking $t = 0$ since it implies $c = 0$, but we would prefer to let him or her pick $t = p$ for instance.

        Thus, we need to understand $\left(\mathbb{Z} / m\mathbb{Z}, \cdot\right)$ when $m = pq$. We notice that there is a very good way to see $\Mod pq$ through the Chinese remainder theorem. Indeed, this theorem tells us that we have the bijective mapping $\left[a\right]_{pq} \leftrightarrow \left(\left[a\right]_p, \left[a\right]_q\right)$ which allows us to multiply numbers as: 
        \[\left[ab\right]_{pq} \leftrightarrow \left(\left[ab\right]_p, \left[ab\right]_q\right) = \left(\left[a\right]_p, \left[b\right]_p\right) \cdot \left(\left[a\right]_q, \left[b\right]_q\right)\]

        Combining all we did, we find that: 
        \[\left(\left[a\right]_{pq}\right)^{\ell k + 1} = \left[a\right]_{pq}, \mathspace \forall a, \ell\]
        where $k$ is a multiple of both $\left(p-1\right)$ and $\left(q-1\right)$.
    }

    \subparag{Diagram}{
        We can make the following diagram to sum up this algorithm:
        \svghere{RSACryptosystem.svg}
    }
    
}

\parag{Weaknesses}{
    Let's say we want to decrypt $c$ without knowing $d$. We can use one of the following ways:
    \begin{itemize}
        \item Factor $m$ to find $p$ and $q$, which is very hard when $m$ is large.
        \item In $\mathbb{Z} / m\mathbb{Z}$, solve $c = x^e$ for $x$. This is very hard to do if $m$ is large, since it requires using discrete logs.
        \item Guess $k, t$ or $d$, which is very hard unless there is some human mistake behind.
    \end{itemize}
}

\subsection{Authenticity}
\parag{Trapdoor one-way functions}{
    We have seen RSA, which uses the concept of trapdoor one-way functions. Let's take a more abstract view of it, considering everything through this kind of functions.

    As already defined, trapdoor one-way functions are functions which are easy to compute in one way and hard to impossible in the other way unless we have a key to the inverse. So, for privacy, Bob can put the forward function $f_B\left(x\right)$ in the public directory, and he can keep the inverse function for himself. To send text to Bob, Alice can publish $c = f_B\left(t\right)$. But then, the only person who can get $t$ is Bob, who knows $f^{-1}_B$, and who can compute $f^{-1}_B\left(f_B\left(t\right)\right) = t$.
    \svghere[0.75]{PrivacyTrapdoorOneWayFunction.svg}
}

 \parag{Digital signature}{
     Let's say Alice wants to sign a document. Alice can publish $\left(t, f_A^{-1}\left(t\right)\right)$. On assumption, nobody can compute $s = f_A^{-1}\left(t\right)$ except for her. Then, Bob can compute $f_A\left(s\right)$, and verify it matches $t$. This allows him to be sure that Alice sent this message and that it was not modified.
    \svghere[0.75]{SigningTrapdoorOneWayFunction.svg}

     Let's now take a look at how it takes place in RSA. Alice can generate a public and a private key, as always. She can then compute $\left(t, \left[t^{d}\right]_{m}\right)$ and send it to Bob. She could only have done that by knowing $d$, which is private. Then, Bob can compute: 
     \[\left(\left[t^{d}\right]_m\right)^e = \left[t\right]_m\]

    He can compare the two texts, and if they match, it means that Alice indeed sent this message. It allows to prevent someone sending a message to Bob by saying they are Alice, or to see that someone modified the message.

    \subparag{Remark}{
        Note that, when Alice sends a message to Bob, privacy relies on $f_B$ whereas authenticity relies on $f_A$.
    }
 }

 \parag{Privacy and digital signatures}{
    If Alice wants to have privacy and prove Bob she sent it, she can do a digital signature, and use Bob's key to cipher both the message and the ciphered text, combining both privacy and digital signatures. In other words, she can send $\left(f_B\left(t\right), f_B\left(f_A^{-1}\left(t\right)\right)\right)$ to Bob.
    \svghere[0.75]{PrivacySigningTrapdoorOneWayFunction.svg}

 }
 
 
 \parag{Hash function}{
     When we send a signed document, we are sending twice our text and this is very inefficient. Thus engineers imagined other methods, hash functions are one of them.

     The idea behind a hash function is a ``many-to-one'' function that converts all binary sequence to a fixed-length binary sequence (of 200 bits for instance). Also, given $h\left(x\right)$, it must be ``very hard'' to find $y$ such that $h\left(y\right) = h\left(x\right)$.

     Then, instead of ciphering her whole text to prove that she has the key, Alice can only sign the hash of her plaintext, sending the ciphered text and $s = f_B\left(f_A^{-1}\left(h\left(t\right)\right)\right)$ to Bob. Then, he can verify that: 
     \[h\left(t\right) \over{=}{\text{?}} f_A\left(f_B^{-1}\left(s\right)\right)\]
 }

 \parag{Trusted agency}{
     Now, the question is how to know that the directory storing all the public keys has not been tampered with. 

     For instance, when Alice asks for the public key of Bob, maybe Eve will change ``Bob's pubic key is $k$'' by ``Bob's public key is $\widetilde{k}$'', which is very dangerous since then Eve would be able to read the message and Bob would not, while Alice thinks that only Bob can.

     To bypass this problem, trusted agencies, such as Symantec, use a public key they generated once, which they store in the hardware of the machine. They then use this public key to sign the key they are sending to us.
 }

 \parag{Standards}{
     There are some of the following standards:
     \begin{itemize}
         \item SHA-1 throuh SHA-3 (Secure Hash Algorithm) family: cryptographic hash functions
         \item DSA (Digital Signature Algorithm), ECDSA (Elliptic Curve DSA): standards for digital signature
         \item DES (Data Encryption Standard), AES (Advanced Encryption Standard): symmetric-key encryption standards. They are faster than RSA and require less memory, but are weaker.
     \end{itemize}

     We could do all those tasks (except for hash) with RSA, some other algorithms are better for specific tasks. RSA takes a lot of effort to compute, thus it is common to send a symmetric key (for Vigenère-like codes) through RSA, and then use it for the rest of the discussion.
}

\end{document}
